{"posts":[{"title":"怎么使用export命令","url":"/posts/export","date":"2021-03-20T00:00:00.000Z","description":"export用法","categories":["web development"],"author":"holobo","content":"\n# export\n\n在创建JavaScript模块时，export 语句用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。被导出的绑定值依然可以在本地进行修改。在使用import进行导入时，这些绑定值只能被导入模块所读取，但在export导出模块中对这些绑定值进行修改，所修改的值也会实时地更新。\n\n无论您是否声明，导出的模块都处于严格模式。 export语句不能用在嵌入式脚本中。\n\n语法\n存在两种 exports 导出方式：\n\n命名导出（每个模块包含任意数量）\n默认导出（每个模块包含一个）\n```\n// 导出单个特性\n\nexport let name1, name2, …, nameN; // also var, const\nexport let name1 = …, name2 = …, …, nameN; // also var, const\nexport function FunctionName(){...}\nexport class ClassName {...}\n\n// 导出列表\nexport { name1, name2, …, nameN };\n\n// 重命名导出\nexport { variable1 as name1, variable2 as name2, …, nameN };\n\n// 解构导出并重命名\nexport const { name1, name2: bar } = o;\n\n// 默认导出\nexport default expression;\nexport default function (…) { … } // also class, function*\nexport default function name1(…) { … } // also class, function*\nexport { name1 as default, … };\n\n// 导出模块合集\nexport * from …; // does not set the default export\nexport * as name1 from …; // Draft ECMAScript® 2O21\nexport { name1, name2, …, nameN } from …;\nexport { import1 as name1, import2 as name2, …, nameN } from …;\nexport { default } from …;\n```\n\nCopy to Clipboard\nnameN\n要导出的标识符（以便其他脚本通过 import 语句进行导入）.\n描述\n有两种不同的导出方式，命名导出和默认导出。你能够在每一个模块中定义多个命名导出，但是只允许有一个默认导出。每种方式对应于上述的一种语法：\n\n```\n命名导出：\n\n// 导出事先定义的特性\nexport { myFunction, myVariable };\n\n// 导出单个特性（可以导出var，let，\n//const,function,class）\nexport let myVariable = Math.sqrt(2);\nexport function myFunction() { ... };\nCopy to Clipboard\n默认导出：\n\n// 导出事先定义的特性作为默认值\nexport { myFunction as default };\n\n// 导出单个特性作为默认值\nexport default function () { ... }\nexport default class { .. }\n```\n\n// 每个导出都覆盖前一个导出\nCopy to Clipboard\n在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称。\n\n但是，可以使用任何名称导入默认导出，例如：\n\n// 文件 test.js\n//let k; export default k = 12; \n//Copy to Clipboard\n// 另一个文件\n//import m from './test'; // 由于 k 是默认导出，所以可以自由使用 import m 替代 import k\nconsole.log(m);        // 输出为 12 \nCopy to Clipboard\n 你也可以重命名命名导出以避免命名冲突：\n\n```\n//export { myFunction as function1,\n         myVariable as variable };\nCopy to Clipboard\n重导出 / 聚合\n为了使模块导入变得可用，在一个父模块中“导入/导出”这些不同模块也是可行的。也就是说，你可以创建单个模块，集中多个模块的多个导出。\n\n这个可以使用“export from”语法实现：\n\nexport { default as function1,\n         function2 } from 'bar.js';\nCopy to Clipboard\n与之形成对比的是联合使用导入和导出：\n\nimport { default as function1,\n         function2 } from 'bar.js';\nexport { function1, function2 };\n```\n\nCopy to Clipboard\n但这里的 function1 和 function2 在当前模块中变得不可用。\n\n```\n备注：尽管与import等效，但以下语法在语法上无效：\n\nimport DefaultExport from 'bar.js'; // 有效的\nCopy to Clipboard\nexport DefaultExport from 'bar.js'; // 无效的\nCopy to Clipboard\n这里正确的做法是重命名这个导出：\n\nexport { default as DefaultExport } from 'bar.js';\nCopy to Clipboard\n示例\n使用命名导出\n在模块 my-module.js 中，可能包含以下代码：\n\n// module \"my-module.js\"\nfunction cube(x) {\n  return x * x * x;\n}\n\nconst foo = Math.PI + Math.SQRT2;\n\nvar graph = {\n    options: {\n        color:'white',\n        thickness:'2px'\n    },\n    draw: function() {\n        console.log('From graph draw function');\n    }\n}\n\nexport { cube, foo, graph };\nCopy to Clipboard\n然后，在你的 HTML 页面的顶级模块中：\n\nimport { cube, foo, graph } from 'my-module.js';\n\ngraph.options = {\n    color:'blue',\n    thickness:'3px'\n};\n\ngraph.draw();\nconsole.log(cube(3)); // 27\nconsole.log(foo);    // 4.555806215962888\nCopy to Clipboard\n```\n\n着重注意以下几点：\n\n在你的 HTML 中需要包含 type=\"module\" 的 script 元素这样的脚本，以便它被识别为模块并正确处理\n不能通过 file:// URL 运行 JS 模块 — 这将导致 CORS 错误。你需要通过 HTTP 服务器运行。\n使用默认导出\n\n```\n如果我们要导出一个值或得到模块中的返回值，就可以使用默认导出：\n// module \"my-module.js\"\n\nexport default function cube(x) {\n  return x * x * x;\n}\nCopy to Clipboard\n然后，在另一个脚本中，可以直接导入默认导出：\n\nimport cube from './my-module.js';\nconsole.log(cube(3)); // 27\nCopy to Clipboard\n模块重定向\n举个例子，假如我们有如下层次结构：\n\nchildModule1.js: 导出 myFunction 和 myVariable\nchildModule2.js: 导出 myClass\nparentModule.js: 作为聚合器（不做其他事情）\n顶层模块：调用 parentModule.js 的导出项\n你的代码看起来应该像这样：\n\n// childModule1.js 中\nlet myFunction = ...; // assign something useful to myFunction\nlet myVariable = ...; // assign something useful to myVariable\nexport {myFunction, myVariable};\nCopy to Clipboard\n// childModule2.js 中\nlet myClass = ...; // assign something useful to myClass\nexport myClass;\nCopy to Clipboard\n// parentModule.js 中\n// 仅仅聚合 childModule1 和 childModule2 中的导出\n// 以重新导出他们\nexport { myFunction, myVariable } from 'childModule1.js';\nexport { myClass } from 'childModule2.js';\nCopy to Clipboard\n// 顶层模块中\n// 我们可以从单个模块调用所有导出，因为 parentModule 事先\n// 已经将他们“收集”/“打包”到一起\nimport { myFunction, myVariable, myClass } from 'parentModule.js'\n```\n"},{"title":"git使用心得","url":"/posts/git","date":"2022-03-28T00:00:00.000Z","description":"git用法","categories":["web","github"],"author":"holobo","content":"\n# github\n  代码修改成功后，需要push到github的操作如下：\n## 一、 cd Develop/holobo 进入目标文件夹\n## 二、显示并进行分支操作\n  _git branch_\n```\ngit branch                       # 显示本地分支\ngit branch --contains 50089      # 显示包含提交50089的分支\ngit branch -a                    # 显示所有分支\ngit branch -r                    # 显示所有原创分支\ngit branch --merged              # 显示所有已合并到当前分支的分支\ngit branch --no-merged           # 显示所有未合并到当前分支的分支\ngit branch -m master master_copy # 本地分支改名\ngit show-branch                  # 图示当前分支历史\ngit show-branch --all            # 图示所有分支历史\n```\n  _git checkout_\n```\ngit checkout -b master_copy          # 从当前分支创建新分支master_copy并检出\ngit checkout -b master master_copy   # 上面的完整版\ngit checkout features/performance    # 检出已存在的features/performance分支\ngit checkout --track hotfixes/BJVEP933   # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支\ngit checkout v2.0                        # 检出版本v2.0\ngit checkout -b devel origin/develop     # 从远程分支develop创建新本地分支devel并检出\ngit checkout -- README       # 检出head版本的README文件（可用于修改错误回退）\n```\n  _git diff_\n```\ngit diff                       # 显示所有未添加至index的变更\ngit diff --cached              # 显示所有已添加index但还未commit的变更\ngit diff HEAD^                 # 比较与上一个版本的差异\ngit diff HEAD -- ./lib         # 比较与HEAD版本lib目录的差异\ngit diff origin/master..master # 比较远程分支master上有本地分支master上没有的\ngit diff origin/master..master --stat      # 只显示差异的文件，不显示具体内容\n```\n  _git log\\show_\n```\ngit log                        # 显示提交日志\ngit log -1                     # 显示1行日志 -n为n行\ngit log --stat                 # 显示提交日志及相关变动文件\ngit log -p -m\ngit show dfb02                 # 可只用commitid的前几位\ngit show HEAD                  # 显示HEAD提交日志\ngit show HEAD^                 # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本\ngit show v2.0                  # 显示v2.0的日志及详细内容\ngit log v2.0                   # 显示v2.0的日志\n```\n## 三、添加改动\n  _git add_\n```\ngit add xyz                    # 添加xyz文件至index\ngit add .                      # 增加当前子目录下所有更改过的文件至index\n```\n## 四、查看状态是否添加成功\n _git status_\n ```\n git status                    # 查看当前版本状态（是否修改）\n ```\n## 五、申明改动，添加名称\n  _git commit_\n```\ngit commit -m 'xxx'            # 提交\ngit commit --amend -m 'xxx'    # 合并上一次提交（用于反复修改）\ngit commit -am 'xxx'           # 将add和commit合为一步\n```\n## 六、重新查看status，随后push\n  _git push_\n```\ngit push --set-upstream origin 分支名称\ngit push origin master                # 将当前分支push到远程master分支\ngit push origin :hotfixes/BJVEP933    # 删除远程仓库的hotfixes/BJVEP933分支\ngit push --tags                       # 把所有tag推送到远程仓库\n```\n## 七、从github仓库里回拉文件\n  _git pull_\n```\ngit pull origin master           # 获取远程分支master并merge到当前分支\n```\n## 八、放入暂存区，以栈堆的形式，先进后出，后进先出的方式存放。\n  _git stash_\n```\ngit stash                        # 暂存当前修改，将所有至为HEAD状态\ngit stash list                   # 查看所有暂存\ngit stash show -p stash@{0}      # 参考第一次暂存\ngit stash apply stash@{0}        # 应用第一次暂存\ngit stash pop                    # 释放存储\n```\n## 九、特别注意，一般工作首先新建test分支进行改动，最后提交也是test，待test审核通过后，本地进行pull，成功后删除test，保留原主项目。\n"},{"title":"怎么使用markdown","url":"/posts/markdown","date":"2021-03-19T00:00:00.000Z","description":"markdown常用语法举例","categories":["web development"],"author":"holobo","content":"\n# Markdown Examples\n\n## h2 Heading\n\n### h3 Heading\n\n#### h4 Heading\n\n##### h5 Heading\n\n###### h6 Heading\n\n## Emphasis\n\n**This is bold text**\n\n_This is italic text_\n\n~~Strikethrough~~\n\n## Blockquotes\n\n> Develop. Preview. Ship. – Vercel\n\n## Lists\n\nUnordered\n\n- Lorem ipsum dolor sit amet\n- Consectetur adipiscing elit\n- Integer molestie lorem at massa\n\nOrdered\n\n1. Lorem ipsum dolor sit amet\n2. Consectetur adipiscing elit\n3. Integer molestie lorem at massa\n\n---\n---\n\n## Code\n\nInline `code`\n\n```\nexport default function Nextra({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <link\n          rel=\"alternate\"\n          type=\"application/rss+xml\"\n          title=\"RSS\"\n          href=\"/feed.xml\"\n        />\n        <link\n          rel=\"preload\"\n          href=\"/fonts/Inter-roman.latin.var.woff2\"\n          as=\"font\"\n          type=\"font/woff2\"\n          crossOrigin=\"anonymous\"\n        />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}\n```\n\n## Tables\n\n| **Option** | **Description**                                                                                                             |\n| ---------- | --------------------------------------------------------------------------------------------------------------------------- |\n| First      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\n| Second     | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\n| Third      | Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. |\n\n## Links\n\n- [Next.js](https://nextjs.org)\n- [Nextra](https://nextra.vercel.app/)\n- [Vercel](http://vercel.com)\n\n### Footnotes\n\n- Footnote [^1].\n- Footnote [^2].\n\n[^1]: Footnote **can have markup**\n\nand multiple paragraphs.\n\n[^2]: Footnote text.\n"},{"title":"如何使用Next.js","url":"/posts/next","date":"2021/3/18","description":"学会如何使用nextjs","categories":["web development"],"author":"holobo","content":"\n# Next.js Pages\n\nIn Next.js, a **page** is a [React Component](https://reactjs.org/docs/components-and-props.html) exported from a `.js`, `.jsx`, `.ts`, or `.tsx` file in the `pages` directory. Each page is associated with a route based on its file name.\n\n**Example**: If you create `pages/about.js` that exports a React component like below, it will be accessible at `/about`.\n\n```\nfunction About() {\n  return <div>About</div>\n}\n\nexport default About\n```\n\n### Pages with Dynamic Routes\n\nNext.js supports pages with dynamic routes. For example, if you create a file called `pages/posts/[id].js`, then it will be accessible at `posts/1`, `posts/2`, etc.\n\n> To learn more about dynamic routing, check the [Dynamic Routing documentation](/docs/routing/dynamic-routes.md).\n\n## Pre-rendering\n\nBy default, Next.js **pre-renders** every page. This means that Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript. Pre-rendering can result in better performance and SEO.\n\nEach generated HTML is associated with minimal JavaScript code necessary for that page. When a page is loaded by the browser, its JavaScript code runs and makes the page fully interactive. (This process is called _hydration_.)\n\n### Two forms of Pre-rendering\n\nNext.js has two forms of pre-rendering: **Static Generation** and **Server-side Rendering**. The difference is in **when** it generates the HTML for a page.\n\n- [**Static Generation (Recommended)**](#static-generation-recommended): The HTML is generated at **build time** and will be reused on each request.\n- [**Server-side Rendering**](#server-side-rendering): The HTML is generated on **each request**.\n\nImportantly, Next.js lets you **choose** which pre-rendering form you'd like to use for each page. You can create a \"hybrid\" Next.js app by using Static Generation for most pages and using Server-side Rendering for others.\n\nWe **recommend** using **Static Generation** over Server-side Rendering for performance reasons. Statically generated pages can be cached by CDN with no extra configuration to boost performance. However, in some cases, Server-side Rendering might be the only option.\n\nYou can also use **Client-side Rendering** along with Static Generation or Server-side Rendering. That means some parts of a page can be rendered entirely by client side JavaScript. To learn more, take a look at the [Data Fetching](/docs/basic-features/data-fetching/client-side.md) documentation.\n\n## Static Generation (Recommended)\n\nIf a page uses **Static Generation**, the page HTML is generated at **build time**. That means in production, the page HTML is generated when you run `next build` . This HTML will then be reused on each request. It can be cached by a CDN.\n\nIn Next.js, you can statically generate pages **with or without data**. Let's take a look at each case.\n\n### Static Generation without data\n\nBy default, Next.js pre-renders pages using Static Generation without fetching data. Here's an example:\n\n```\nfunction About() {\n  return <div>About</div>\n}\n\nexport default About\n```\n\nNote that this page does not need to fetch any external data to be pre-rendered. In cases like this, Next.js generates a single HTML file per page during build time.\n\n### Static Generation with data\n\nSome pages require fetching external data for pre-rendering. There are two scenarios, and one or both might apply. In each case, you can use a special function Next.js provides:\n\n1. Your page **content** depends on external data: Use `getStaticProps`.\n2. Your page **paths** depend on external data: Use `getStaticPaths` (usually in addition to `getStaticProps`).\n\n#### Scenario 1: Your page **content** depends on external data\n\n**Example**: Your blog page might need to fetch the list of blog posts from a CMS (content management system).\n\n```\n// TODO: Need to fetch `posts` (by calling some API endpoint)\n//       before this page can be pre-rendered.\nfunction Blog({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li>{post.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nexport default Blog\n```\n\nTo fetch this data on pre-render, Next.js allows you to `export` an `async` function called `getStaticProps` from the same file. This function gets called at build time and lets you pass fetched data to the page's `props` on pre-render.\n\n```\nfunction Blog({ posts }) {\n  // Render posts...\n}\n\n// This function gets called at build time\nexport async function getStaticProps() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n\n  // By returning { props: { posts } }, the Blog component\n  // will receive `posts` as a prop at build time\n  return {\n    props: {\n      posts\n    }\n  }\n}\n\nexport default Blog\n```\n\nTo learn more about how `getStaticProps` works, check out the [Data Fetching documentation](/docs/basic-features/data-fetching/get-static-props.md).\n\n#### Scenario 2: Your page paths depend on external data\n\nNext.js allows you to create pages with **dynamic routes**. For example, you can create a file called `pages/posts/[id].js` to show a single blog post based on `id`. This will allow you to show a blog post with `id: 1` when you access `posts/1`.\n\n> To learn more about dynamic routing, check the [Dynamic Routing documentation](/docs/routing/dynamic-routes.md).\n\nHowever, which `id` you want to pre-render at build time might depend on external data.\n\n**Example**: suppose that you've only added one blog post (with `id: 1`) to the database. In this case, you'd only want to pre-render `posts/1` at build time.\n\nLater, you might add the second post with `id: 2`. Then you'd want to pre-render `posts/2` as well.\n\nSo your page **paths** that are pre-rendered depend on external data**.** To handle this, Next.js lets you `export` an `async` function called `getStaticPaths` from a dynamic page (`pages/posts/[id].js` in this case). This function gets called at build time and lets you specify which paths you want to pre-render.\n\n```\n// This function gets called at build time\nexport async function getStaticPaths() {\n  // Call an external API endpoint to get posts\n  const res = await fetch('https://.../posts')\n  const posts = await res.json()\n\n  // Get the paths we want to pre-render based on posts\n  const paths = posts.map((post) => ({\n    params: { id: post.id }\n  }))\n\n  // We'll pre-render only these paths at build time.\n  // { fallback: false } means other routes should 404.\n  return { paths, fallback: false }\n}\n```\n\nAlso in `pages/posts/[id].js`, you need to export `getStaticProps` so that you can fetch the data about the post with this `id` and use it to pre-render the page:\n\n```\nfunction Post({ post }) {\n  // Render post...\n}\n\nexport async function getStaticPaths() {\n  // ...\n}\n\n// This also gets called at build time\nexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(`https://.../posts/${params.id}`)\n  const post = await res.json()\n\n  // Pass post data to the page via props\n  return { props: { post } }\n}\n\nexport default Post\n```\n\nTo learn more about how `getStaticPaths` works, check out the [Data Fetching documentation](/docs/basic-features/data-fetching/get-static-paths.md).\n\n### When should I use Static Generation?\n\nWe recommend using **Static Generation** (with and without data) whenever possible because your page can be built once and served by CDN, which makes it much faster than having a server render the page on every request.\n\nYou can use Static Generation for many types of pages, including:\n\n- Marketing pages\n- Blog posts\n- E-commerce product listings\n- Help and documentation\n\nYou should ask yourself: \"Can I pre-render this page **ahead** of a user's request?\" If the answer is yes, then you should choose Static Generation.\n\nOn the other hand, Static Generation is **not** a good idea if you cannot pre-render a page ahead of a user's request. Maybe your page shows frequently updated data, and the page content changes on every request.\n\nIn cases like this, you can do one of the following:\n\n- Use Static Generation with **Client-side Rendering:** You can skip pre-rendering some parts of a page and then use client-side JavaScript to populate them. To learn more about this approach, check out the [Data Fetching documentation](/docs/basic-features/data-fetching/client-side.md).\n- Use **Server-Side Rendering:** Next.js pre-renders a page on each request. It will be slower because the page cannot be cached by a CDN, but the pre-rendered page will always be up-to-date. We'll talk about this approach below.\n\n## Server-side Rendering\n\n> Also referred to as \"SSR\" or \"Dynamic Rendering\".\n\nIf a page uses **Server-side Rendering**, the page HTML is generated on **each request**.\n\nTo use Server-side Rendering for a page, you need to `export` an `async` function called `getServerSideProps`. This function will be called by the server on every request.\n\nFor example, suppose that your page needs to pre-render frequently updated data (fetched from an external API). You can write `getServerSideProps` which fetches this data and passes it to `Page` like below:\n\n```\nfunction Page({ data }) {\n  // Render data...\n}\n\n// This gets called on every request\nexport async function getServerSideProps() {\n  // Fetch data from external API\n  const res = await fetch(`https://.../data`)\n  const data = await res.json()\n\n  // Pass data to the page via props\n  return { props: { data } }\n}\n\nexport default Page\n```\n\nAs you can see, `getServerSideProps` is similar to `getStaticProps`, but the difference is that `getServerSideProps` is run on every request instead of on build time.\n\nTo learn more about how `getServerSideProps` works, check out our [Data Fetching documentation](/docs/basic-features/data-fetching/get-server-side-props.md)\n\n## Summary\n\nWe've discussed two forms of pre-rendering for Next.js.\n\n- **Static Generation (Recommended):** The HTML is generated at **build time** and will be reused on each request. To make a page use Static Generation, either export the page component, or export `getStaticProps` (and `getStaticPaths` if necessary). It's great for pages that can be pre-rendered ahead of a user's request. You can also use it with Client-side Rendering to bring in additional data.\n- **Server-side Rendering:** The HTML is generated on **each request**. To make a page use Server-side Rendering, export `getServerSideProps`. Because Server-side Rendering results in slower performance than Static Generation, use this only if absolutely necessary.\n"}]}